//arbre pondéré commit chill pepouze
import java.util.*;

/x;sx;m<s;x<xlmmsl;mls<x

public class KruskalMST {

    // Map pour stocker le "parent" (représentant) de chaque sommet pour les Composantes Connexes (Union-Find)
    private Map<String, String> parent = new HashMap<>();

    // Initialisation : chaque sommet est son propre parent (CC unique au départ)
    public void initialiserCC(Set<String> sommets) {
        for (String s : sommets) {
            parent.put(s, s);
        }
    }

    // Trouver le représentant (la racine) de la composante connexe d'un sommet
    public String trouverRepresentant(String sommet) {
        if (parent.get(sommet).equals(sommet)) {
            return sommet;
        }
        // Compression de chemin pour optimiser les futurs appels
        String representant = trouverRepresentant(parent.get(sommet));
        parent.put(sommet, representant); 
        return representant;
    }

    // Unir deux composantes connexes
    public void unir(String sommet1, String sommet2) {
        String racine1 = trouverRepresentant(sommet1);
        String racine2 = trouverRepresentant(sommet2);
        if (!racine1.equals(racine2)) {
            parent.put(racine1, racine2); // On attache l'arbre 1 sous l'arbre 2
        }
    }

    public void executerkruskal(List<Arete> toutesLesAretes, Set<String> sommets) {
        // 1. Trier les arêtes par poids croissant
        Collections.sort(toutesLesAretes);

        // 2. Initialiser les CC
        initialiserCC(sommets);

        List<Arete> acpm = new ArrayList<>();
        int poidsTotal = 0;

        System.out.println("--- DÉBUT DE L'ALGORITHME DE KRUSKAL ---");
        System.out.println("Arête\tPoids\tSélectionnée ?\tComposantes Connexes (Représentants)");

        for (Arete arete : toutesLesAretes) {
            String u = arete.source;
            String v = arete.destination;

            String racineU = trouverRepresentant(u);
            String racineV = trouverRepresentant(v);

            boolean selectionnee = false;

            // Si les sommets sont dans des CC différentes, on prend l'arête (pas de cycle)
            if (!racineU.equals(racineV)) {
                acpm.add(arete);
                poidsTotal += arete.poids;
                unir(u, v);
                selectionnee = true;
            }

            // Affichage de l'état actuel (similaire à votre tableau)
            System.out.print(arete + "\t\t" + (selectionnee ? "OUI" : "NON") + "\t\t");
            afficherEtatCC(sommets);
        }

        System.out.println("\n--- RÉSULTAT FINAL ---");
        System.out.println("Arêtes de l'ACPM : " + acpm);
        System.out.println("Poids total de l'arbre : " + poidsTotal);
    }

    // Méthode utilitaire pour afficher l'état des CC (pour le débogage visuel)
    private void afficherEtatCC(Set<String> sommets) {
        Map<String, List<String>> groupes = new HashMap<>();
        for (String s : sommets) {
            String rep = trouverRepresentant(s);
            groupes.putIfAbsent(rep, new ArrayList<>());
            groupes.get(rep).add(s);
        }
        System.out.println(groupes.values());
    }

    public static void main(String[] args) {
        KruskalMST algo = new KruskalMST();

        // 1. Définition des sommets (A à J + Centre Traitement "CT")
        Set<String> sommets = new HashSet<>(Arrays.asList("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "CT"));

        // 2. Création des arêtes selon vos images (Graphe complet pondéré)
        List<Arete> aretes = new ArrayList<>();
        
        // Poids 1
        aretes.add(new Arete("CT", "B", 1)); // Centre de traitement -> B

        // Poids 2
        aretes.add(new Arete("C", "D", 2));
        aretes.add(new Arete("B", "J", 2)); // Note: B-J est marqué 2 sur le schéma final
        aretes.add(new Arete("E", "F", 2));
        aretes.add(new Arete("F", "G", 2));
        aretes.add(new Arete("C", "H", 2)); // Supposé d'après le tableau final (étape 7/8/9) ou contexte manquant, ajusté ici. 

    }
}
