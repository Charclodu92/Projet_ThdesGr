//arbre pondéré commit chill pepouze
import java.util.*;

// Classe représentant une arête avec un poids
class Arete implements Comparable<Arete> {
    String source;
    String destination;
    int poids;

    public Arete(String source, String destination, int poids) {
        this.source = source;
        this.destination = destination;
        this.poids = poids;
    }

    // Permet de trier les arêtes par poids croissant
    @Override
    public int compareTo(Arete autre) {
        return this.poids - autre.poids;
    }

    @Override
    public String toString() {
        return source + "-" + destination + " (" + poids + ")";
    }
}

public class KruskalMST {

    // Map pour stocker le "parent" (représentant) de chaque sommet pour les Composantes Connexes (Union-Find)
    private Map<String, String> parent = new HashMap<>();

    // Initialisation : chaque sommet est son propre parent (CC unique au départ)
    public void initialiserCC(Set<String> sommets) {
        for (String s : sommets) {
            parent.put(s, s);
        }
    }

    // Trouver le représentant (la racine) de la composante connexe d'un sommet
    public String trouverRepresentant(String sommet) {
        if (parent.get(sommet).equals(sommet)) {
            return sommet;
        }
        // Compression de chemin pour optimiser les futurs appels
        String representant = trouverRepresentant(parent.get(sommet));
        parent.put(sommet, representant); 
        return representant;
    }

    // Unir deux composantes connexes
    public void unir(String sommet1, String sommet2) {
        String racine1 = trouverRepresentant(sommet1);
        String racine2 = trouverRepresentant(sommet2);
        if (!racine1.equals(racine2)) {
            parent.put(racine1, racine2); // On attache l'arbre 1 sous l'arbre 2
        }
    }

    public void executerkruskal(List<Arete> toutesLesAretes, Set<String> sommets) {
        // 1. Trier les arêtes par poids croissant
        Collections.sort(toutesLesAretes);

        // 2. Initialiser les CC
        initialiserCC(sommets);

        List<Arete> acpm = new ArrayList<>();
        int poidsTotal = 0;

        System.out.println("--- DÉBUT DE L'ALGORITHME DE KRUSKAL ---");
        System.out.println("Arête\tPoids\tSélectionnée ?\tComposantes Connexes (Représentants)");

        for (Arete arete : toutesLesAretes) {
            String u = arete.source;
            String v = arete.destination;

            String racineU = trouverRepresentant(u);
            String racineV = trouverRepresentant(v);

            boolean selectionnee = false;

            // Si les sommets sont dans des CC différentes, on prend l'arête (pas de cycle)
            if (!racineU.equals(racineV)) {
                acpm.add(arete);
                poidsTotal += arete.poids;
                unir(u, v);
                selectionnee = true;
            }

            // Affichage de l'état actuel (similaire à votre tableau)
            System.out.print(arete + "\t\t" + (selectionnee ? "OUI" : "NON") + "\t\t");
            afficherEtatCC(sommets);
        }

        System.out.println("\n--- RÉSULTAT FINAL ---");
        System.out.println("Arêtes de l'ACPM : " + acpm);
        System.out.println("Poids total de l'arbre : " + poidsTotal);
    }

    // Méthode utilitaire pour afficher l'état des CC (pour le débogage visuel)
    private void afficherEtatCC(Set<String> sommets) {
        Map<String, List<String>> groupes = new HashMap<>();
        for (String s : sommets) {
            String rep = trouverRepresentant(s);
            groupes.putIfAbsent(rep, new ArrayList<>());
            groupes.get(rep).add(s);
        }
        System.out.println(groupes.values());
    }

    public static void main(String[] args) {
        KruskalMST algo = new KruskalMST();

        // 1. Définition des sommets (A à J + Centre Traitement "CT")
        Set<String> sommets = new HashSet<>(Arrays.asList("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "CT"));

        // 2. Création des arêtes selon vos images (Graphe complet pondéré)
        List<Arete> aretes = new ArrayList<>();
        
        // Poids 1
        aretes.add(new Arete("CT", "B", 1)); // Centre de traitement -> B

        // Poids 2
        aretes.add(new Arete("C", "D", 2));
        aretes.add(new Arete("B", "J", 2)); // Note: B-J est marqué 2 sur le schéma final
        aretes.add(new Arete("E", "F", 2));
        aretes.add(new Arete("F", "G", 2));
        aretes.add(new Arete("C", "H", 2)); // Supposé d'après le tableau final (étape 7/8/9) ou contexte manquant, ajusté ici. 
                                            // Attention : Votre tableau image 4 montre H-J poids 1 à l'étape 7 ? 
                                            // Je me base sur la liste triée de l'image 4 pour les poids.
        
        // Rectification selon votre tableau "Figure T2A2" et le tableau bleu final :
        // Voici les arêtes exactes listées dans votre tableau bleu final :
        // Etape 1: CT-B (1)
        // Etape 2: C-D (2) - ATTENTION: sur le tableau bleu c'est 2, sur la liste triée c'est 2.
        // Etape 3: B-J (2)
        // Etape 4: E-F (3) -> Ah, le tableau bleu dit 3 pour E-F, F-G, A-B...
        // Etape 5: F-G (3)
        // Etape 6: A-B (3)
        // Etape 7: H-J (3)
        // Etape 8: B-E (5)
        // Etape 9: B-D (5)
        
        // Re-création EXACTE de la liste d'entrée basée sur votre tableau bleu et liste triée
        aretes.clear();
        aretes.add(new Arete("CT", "B", 1));
        aretes.add(new Arete("C", "D", 2));
        aretes.add(new Arete("B", "J", 2)); // Poids déduit de l'ordre
        aretes.add(new Arete("E", "F", 2)); // Image 4 dit poids 2
        aretes.add(new Arete("F", "G", 2)); // Image 4 dit poids 2
        
        aretes.add(new Arete("A", "B", 3));
        aretes.add(new Arete("H", "J", 3));
        
        aretes.add(new Arete("B", "E", 5));
        aretes.add(new Arete("B", "D", 5));
        
        aretes.add(new Arete("E", "G", 8));
        aretes.add(new Arete("H", "B", 8));
        
        aretes.add(new Arete("B", "C", 10));

        // Lancement de l'algo
        algo.executerkruskal(aretes, sommets);
    }
}
