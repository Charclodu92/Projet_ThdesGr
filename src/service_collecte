import java.io.File;
import java.io.FileNotFoundException;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;




public class service_collecte {


    private List<RouteCollecte> toutes_les_routes = new ArrayList<>();




    public void charger_reseau_de_collecte(String nomFichier) {
        toutes_les_routes.clear();
        System.out.println("Fichier " + nomFichier);
        try (Scanner sc = new Scanner(new File(nomFichier))) {
            while (sc.hasNextLine()) {
                String ligne = sc.nextLine().trim();
                if (ligne.isEmpty()) continue;
                String[] parts = ligne.split(";");

                if (parts.length >= 4) {
                    try {
                        String nom = parts[0].trim();
                        String secteur1 = parts[1].trim();
                        String secteur2 = parts[2].trim();
                        int dist = Integer.parseInt(parts[3].trim());

                        toutes_les_routes.add(new RouteCollecte(nom, secteur1, secteur2, dist));
                    } catch (NumberFormatException e) {
                        System.out.println("valeur poid invalide " + ligne);
                    }
                }
            }
        } catch (FileNotFoundException e) {
            System.out.println(" Fichier Introuvable");
        }
    }












    public List<RouteCollecte> calculerCircuitMinimum() {

        List<RouteCollecte> arbre = new ArrayList<>();
        Map<String, RouteCollecte> seul = new HashMap<>();
        for (int i = 0; i < toutes_les_routes.size(); i++) {
            RouteCollecte route = toutes_les_routes.get(i);
            String cle;
            if (route.secteurA.compareTo(route.secteurB) < 0) {
                cle = route.secteurA + "-" + route.secteurB;
            } else {
                cle = route.secteurB + "-" + route.secteurA;
            }
            if (!seul.containsKey(cle)) {
                seul.put(cle, route);
            }
            else {
                RouteCollecte routeExistante = seul.get(cle);
                if (route.distance < routeExistante.distance) {
                    seul.put(cle, route);
                }
            }
        }
        List<RouteCollecte> candidates = new ArrayList<>(seul.values());
        Collections.sort(candidates);
        Map<String, String> parent = new HashMap<>();
        for (RouteCollecte r : candidates) {
            parent.putIfAbsent(r.secteurA, r.secteurA);
            parent.putIfAbsent(r.secteurB, r.secteurB);
        }
        for (RouteCollecte route : candidates) {
            String racineA = find(parent, route.secteurA);
            String racineB = find(parent, route.secteurB);

            if (!racineA.equals(racineB)) {
                arbre.add(route);
                union(parent, racineA, racineB);
            }
        }
        return arbre;

    }










    private String find(Map<String, String> parent, String i) {
        if (parent.get(i).equals(i)) return i;
        return find(parent, parent.get(i));
    }






    private void union(Map<String, String> parent, String x, String y) {

        String A = find(parent, x);
        String B = find(parent, y);
        parent.put(A, B);

    }




}
